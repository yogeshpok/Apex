Day First 1 21/12/2025  
https://developer.salesforce.com/docs/platform/lwc/guide
===========================================================
Lightning Web Componenet
-----------------------
Lightning Componenet Using two programing Models:
lightning Web Component and the orignal Model.

Lightning Web Component is Cutom Html component Built using the HTML and Modern JavaScript.

Lightning  Web Componenets and  aura Can Coexits and interoperate on a page to admins and user they both appear as Lightning components.

LWC is the ECMA7 standardization
AURA is the ECMA5 standardization


ECMA7
=============
1) Custom Elements -->
Avoid vendor type of element user neutral tech/element
e.g recom-- HTML,
Lightning-card,Lightning-buttton
<button></button> ---> neutral HTML
<lightning-button></lightning-button> ---> Custom vendor framework --AURA

2)Shadow DOM ---> Encapsulation (HTML + Lightning)
Mixture of the 2 technology is called ShadowDOM.

3)HTML Template ---> UI Frontend Should be .Html

4)ES Module ---> Use of modern JavaScript its not proprietary language
=====================================================================
To create the LWC componenet
-------------------------------
sf lightning generate component --type lwc --name myFirstLwc --output-dir 
sfdx force:auth:web:login -r https://login.salesforce.com/ 
sfdx force:source:deploy -p .\force-app\main\default\lwc\  -u yogesh@selfaura.com -w 20  


LWC Bundle
==============
01. Template     ----> Name.html          --->  HTML,Lightning  ---> UI Designing           --> Componenet
02. ES Module    ----> Name.js            --->  JavaScript      ---> Logic                  --> Cont,Help,rerenderer
03. Interface    ----> Name.js-meta.xml   --->  XML,lightning   ---> LWC Locatio/implement  --> Interface
04. Styles       ----> Name.css           --->  css             ---> Style(Color,SIZE etc)  --> CSS 


aura
No SVG
NO Documentation
No Design
=================================================================================================================
Aspect	              Aura Components	                        Lightning Web Components (LWC)

Framework	          Aura framework	                        Built on modern web standards

Performance	          Generally slower compared to LWC	        Significantly faster due to optimized 
                                                                rendering.

Development Model	  Event-driven and component-based	        More modular and follows a modern JavaScript
                                                                model

Syntax	              Uses Aura-specific markup and JavaScript	Utilizes HTML, JavaScript, and decorators

Learning Curve	      Steeper learning curve for beginners	    Easier for developers familiar with modern web dev

Compatibility	      Compatible with older Salesforce orgs	    May require updates for older systems and browsers

Community Support	  Well-established community and resources	Growing community with increasing support

Integration	          Can integrate with Visualforce and        Seamless integration with Salesforce platform and services
                      other Salesforce technologies	

Flexibility	          Offers flexibility in component       	Provides more flexibility with standard web dev practices
                      structure and design

Component Reusability Components can be reused within 	        Encourages component reusability and composition
                       Aura framework

Lifecycle Hooks	      Aura components have their 	            Uses standard lifecycle hooks
                      lifecycle hooks

Browser Compatibility Compatible with older browsers like       Focuses on modern browser compatibility
                       IE11 	        
=============================================================================================================================
@api
=====
To make the property public recactive use the api decorator.

import {api} from 'lwc';


Wire
====
call the apex method on the backend and get the result
get the records from backend.
wire is by default reactive when we want to automatic load of the records then we can use the reactive wire

üîπ @wire - When the framework should manage data
Key Points:
 - Automatically invoked by the LWC lifecycle
 - Reactive to parameter changes
 - Built-in caching for better performance
‚úî Best for initial data load and read-only UI

üîπ Imperative Calls - When the developer needs control
Key Points:
 - Manually invoked (button click / condition-based)
 - Better error handling
 - Suitable for complex or sequential logic
‚úî Best for user-driven actions and custom workflows

üîÅ When to Use What 
 - Use @wire when data should auto-refresh
 - Use imperative calls when execution depends on user action
syntax :

import {Wire} from 'lwc';

//wire a property
@wire(getAccountINFO,{ srcText :'$sttxt'}) wiredAccounts;

//wire a function
mydata;
myerror;
@wire(getAccountINFO,{ srcText :'$sttxt'}) function({data,error})
{
    if(data)
    {
        this.mydata =data;
    }
    else{
        this.myerror = error
    }
};
================================================================
üî• Tricky @wire Interview Questions & Answers
Is @wire reactive or imperative?
=> @wire is reactive by default. It automatically runs when the component loads and when reactive parameters change.

Can we call @wire on button click?
=> No. @wire cannot be called manually.
For button clicks, use imperative Apex calls.

If there are multiple @wire functions, is execution order guaranteed?
=> No. Multiple @wire adapters execute independently and asynchronously.
If order is required, use reactive parameters or imperative calls.

Can one @wire call another @wire?
=> No.
But one wire can trigger another indirectly using reactive parameters ($).

Why do we use $ before a parameter in @wire?
=> $ makes the parameter reactive, so the wire re-executes automatically when the value changes.

What happens if a reactive parameter is undefined?
=> The wire does not execute until the parameter gets a valid value.

Can @wire be used with any Apex method?
=> No.
The Apex method must be annotated with:
@AuraEnabled(cacheable=true)

Can we use @wire for DML operations?
=> No.
@wire is for read-only operations only.
DML must be done imperatively.

What is the difference between wired property and wired function?
=> Wired Property	Wired Function
   Simpler	        More control
   No logic	        Custom logic
 Auto assignment	Manual assignment
// Property
@wire(getAccounts) accounts;

// Function
@wire(getAccounts)
wiredAccounts({ data, error }) {
    if (data) { this.accounts = data; }
}

Does @wire always cache data?
=> Caching works only when:
Using LDS adapters, OR
Apex method is @AuraEnabled(cacheable=true)

Can we stop a wire from running?
=> Yes, by:
Making the reactive parameter undefined or null

@wire(getAccounts, { accId: '$accountId' })
accounts;

// wire won't run if accountId is undefined

When should we avoid using @wire?
=> Avoid @wire when:
Action is user-triggered
Conditional logic is needed
Error handling is complex
DML operations are required

Is @wire synchronous or asynchronous?
=> @wire is asynchronous.

Can we refresh wired data manually?
=> Yes, using refreshApex().

Interview Killer One-Liner
=> @wire is reactive, read-only, and framework-controlled; imperative calls are manual, flexible, and developer-controlled.
==========================================================================================================================================
LWC LDS
========
Lightning Data Service does a lot of work to make code perform well.
Loads record data progressively.
Caches results on the client.
Invalidates cache entries when dependent Salesforce data and metadata changes.
Optimizes server calls by bulkifying and reducing requests.

01. Form based
========================
a) lightning record view form ---> lightning output field
b) lightning record edit form --->  lightning input field
c) lightning record  form --->  Nothing

lightning-record-edit-form    ‚Äî Displays an editable form.
lightning-record-view-form    ‚Äî Displays a read-only form.
lightning-record-form         ‚Äî Supports edit, view, and read-only modes.

Feature	             lightning-record-form	lightning-record-view-form	lightning-record-edit-form
Create Records	                Yes	 	                                   Yes
Edit Records	                Yes	 	                                   Yes
View Records	                Yes	            Yes	 
https://developer.salesforce.com/docs/component-library/bundle/lightning-record-edit-form/documentation
https://developer.salesforce.com/docs/component-library/bundle/lightning-record-form/documentation
https://developer.salesforce.com/docs/component-library/bundle/lightning-record-view-form/documentation

02) programing based
====================================
a) wire service --> retrival of data

b) Imperative service (direct from LWC - No apex class)
    a) create record => createRecord(recordInput)
    b) Update record => updateRecord(recordInput)
    c) Delete record => deleteRecord(recordId)
    d) get record =>  
https://developer.salesforce.com/docs/platform/lwc/guide/reference-delete-record.html

3) Server side Imperation (Apex Call)   


===================================================================================================================================
Here is a simple breakdown of Promise vs Promise.all():

Promise
Used when you have one asynchronous operation.
Executes a single async task
Runs sequentially
Handles success or failure using .then() and .catch()
Best for one Apex call at a time

Example use case:
Fetching Account data from one Apex method.

Promise.all()
Used when you need to run multiple independent async operations in parallel.
Executes multiple async tasks together
Improves performance by running calls simultaneously
Resolves only when all promises succeed
If one fails, the entire operation goes to .catch()

Example use case:
Fetching Accounts, Contacts, and Opportunities at the same time.

Key Difference
--------------
Use Promise for a single async task
Use Promise.all() for multiple async tasks that can run in parallel

Simple takeaway:
Parallel execution = better performance, when tasks are independent.

Lifecycle Hooks
=====================
A lifecycle hook is a callback method that triggers at a specific phase of a component instances lifecycle. 
With LWC, you can use the following lifecycle hooks.

constructor()
connectedCallback() and disconnectedCallback()
renderedCallback()
errorCallback()

Lightning web components have a lifecycle managed by the framework. 
The framework creates components, inserts them into the DOM, renders them, and removes them from the DOM. 
It also monitors components for property changes.

constructor()
---------------------
The constructor() method fires when a component instance is created. 
Dont add attributes to the host element during construction. 
You can add attributes to the host element in any other lifecycle hook.
The constructor flows from parent to child, which means that it fires in the parent first. 
You can't access child elements because they don't exist yet. Properties arent passed yet, either. 
Properties are assigned to the component after construction and before the connectedCallback() hook.

Constructor Considerations 
===========================
These requirements from the HTML: Custom elements spec apply to the constructor().
The first statement must be super() with no parameters. This call establishes the correct prototype chain and value for this. Always call super() before touching this.
Don‚Äôt use a return statement inside the constructor body, unless it is a simple early-return (return or return this).
Don‚Äôt use the document.write() or document.open() methods.
Don‚Äôt inspect the element's attributes and children, because they don‚Äôt exist yet.
Don‚Äôt inspect the element‚Äôs public properties, because they‚Äôre set after the component is created.

connectedCallback()
---------------------
the connectedCallback() lifecycle hook fires when a component is inserted into the DOM. 
The disconnectedCallback() lifecycle hook fires when a component is removed or hidden from the DOM. 
Both hooks flow from parent to child. To access the host element, use this. To access elements in a component‚Äôs template, use this.template.
Use
====
Establish communication with the current document or container and coordinate behavior with the environment.
Perform initialization tasks, such as fetch data, set up caches, or listen for events
Subscribe and Unsubscribe from a Message Channel.
Navigate to different page types, like records and list views using the lightning/navigation module.
Work with third-party web components.

disconnectedCallback() 
-----------------------
The disconnectedCallback() lifecycle hook fires when a component is removed or hidden from the DOM. 
Use disconnectedCallback() to clean up work done in the connectedCallback(), like purging caches or removing event listeners.

renderedCallback()
------------------
The renderedCallback() lifecycle hook is unique to Lightning Web Components.
Use it to perform logic after a component has finished the rendering phase. This hook flows from child to parent.

Render 
------
Call the render() method to update the UI. You can call it before or after connectedCallback().

errorCallback()
----------------
The errorCallback() hook is unique to Lightning Web Components. 
Implement it to create an error boundary component that captures errors in all the descendent components in its tree. 
Like a JavaScript catch{} block, errorCallback() captures errors that occur in lifecycle hooks or during an event handler declared in an HTML template. 
You can code the error boundary component to log stack information and render an alternative view to tell users what happened and what to do next.

lets say there were 2 Component One is parent and another is child What should be the lifecycle for that.
=>
 PARENT constructor
 PARENT connectedCallback
 PARENT render
 CHILD constructor
 CHILD connectedCallback
 CHILD render
 CHILD renderedCallback
 DOM accessed in renderedCallback
 PARENT renderedCallback
------------------------------------------------------------------------------
ShadowDom
************
what is Dom ?
DOM is a programing API for html and XML document .it defines the logical structure of document and the way a document is acessed and Manipulated.
basically Dom is a tree Structure representation of the web page.

what is the Shadow Dom ?
shadow Dom brings encapsulation concept of the html which enables the you link hidden seprated Dom to an element.

benifit
Dom Queries event propogation and css rule cannot goto other side of the shadow boundry.thus creating encapsulation.


Aceessing element in lWC
----------------------------
to acess element rendered by a component use the template property.

this.template.querySelector(selector);
this.template.querySelectorAll(selector);
element.template.querySelectorAll(selector);

Note :dont use ID selector with queryselector.

lwc:dom ="mannual"

add this directive to a native html element to attach an element as a child.

HelloQuerySelectorDemo.html
-----------------------------
<template>
    <lightning-card title="querySelector">
        <div class="slds-var-m-around_medium">
            <h1>Hey I am heading</h1>
            <template for:each={userNames} for:item="user">
                <div class="name" key={user}>{user}</div>
            </template>
            <div class="child" lwc:dom="manual"></div>
             <button onclick={fetchDetailHandler}>Fetch details</button>
        </div>
    </lightning-card>
</template>

HelloQuerySelectorDemo.js
----------------------------
import { LightningElement } from 'lwc';

export default class HelloQuerySelectorDemo extends LightningElement {
    userNames =["John", "Smith", "Nik", "Mike"]
    fetchDetailHandler(){
        const elem = this.template.querySelector('h1')
        elem.style.border="1px solid red";
        console.log(elem.innerText)

        const userElements = this.template.querySelectorAll('.name')
        Array.from(userElements).forEach(item=>{
            console.log(item.innerText)
            item.setAttribute("title", item.innerText)
        })

        ///  lwc:dom="manual" demo
        const childElem = this.template.querySelector('.child')
        childElem.innerHTML = '<p>Hey i am a child element</p>'
    }
}

========================================================
1 PubSub in LWC (Legacy / Custom Pattern)
------------------------------------------
üîπ What is PubSub?
A custom JavaScript event bus used to communicate between:
components without parent-child relationship 
mainly used before LMS existed

üîπ How PubSub works
Uses a shared JS file (pubsub.js)
Components register, fire, and unregister events manually

üîπ Use Case
Sibling components
LWC ‚Üí Aura communication (old projects)

üîπ Limitations ‚ùå
Problem
Not officially supported
Manual cleanup required
Not reactive
Can cause memory leaks
Not cross-DOM safe
üîπ Interview One-Liner

PubSub is a custom event pattern and is not recommended for new LWC development.

2 Lightning Message Service (LMS) ‚úÖ (Recommended)
---------------------------------------------------

üîπ What is LMS?
Salesforce standard, supported messaging framework for:

LWC ‚Üî LWC
LWC ‚Üî Aura
Across DOM trees

üîπ Key Features

‚úî Decoupled communication
‚úî Reactive
‚úî Auto cleanup
‚úî Secure
‚úî Cross-namespace safe

üîπ LMS Architecture
Publisher ‚Üí Message Channel ‚Üí Subscriber

üîπ LMS Files Required

1 Message Channel metadata
2 Publisher component
3 Subscriber component



PUBSUB AND LIGHTNING MESSAGE SERVICE (LMS) - LWC QUESTIONS & ANSWERS
=================================================================

1. What is PubSub in LWC?
Answer:
PubSub is a custom JavaScript event-based communication pattern used to communicate between unrelated components.
It is not officially supported by Salesforce and is considered legacy.

2. Is PubSub reactive?
Answer:
No. PubSub is event-driven, not reactive.

3. Is PubSub recommended for new LWC development?
Answer:
No. Salesforce recommends using Lightning Message Service instead.

4. What is Lightning Message Service (LMS)?
Answer:
LMS is a Salesforce-supported messaging framework that enables communication between Aura and LWC components
without a direct relationship.

5. Is LMS reactive?
Answer:
Yes. Subscribers automatically react when a message is published.

6. Does LMS require parent-child relationship?
Answer:
No. LMS works for completely decoupled components.

7. Can LMS communicate between LWC and Aura?
Answer:
Yes. LMS supports LWC ‚Üî Aura communication.

8. What are the main parts of LMS?
Answer:
1) Message Channel
2) Publisher
3) Subscriber

9. Where is the message channel stored?
Answer:
In force-app/main/default/messageChannels folder.

10. Is message channel an LWC component?
Answer:
No. It is metadata of type LightningMessageChannel.

11. Which decorator is mandatory for LMS?
Answer:
@wire(MessageContext)

12. Can LMS pass complex objects?
Answer:
Yes, but only serializable data (no functions or DOM elements).

13. Can one component both publish and subscribe?
Answer:
Yes.

14. What happens if no subscriber exists?
Answer:
The message is ignored, no error occurs.

15. Is cleanup required in LMS?
Answer:
No. Salesforce handles cleanup automatically.

16. Is PubSub cross-DOM safe?
Answer:
No.

17. Is LMS cross-DOM safe?
Answer:
Yes.

18. Can LMS work in Salesforce Mobile App?
Answer:
Yes.

19. Can LMS be used in Experience Cloud?
Answer:
Yes.

20. Biggest mistake while deploying LMS?
Answer:
Using LightningComponentBundle instead of LightningMessageChannel in package.xml.

21. When should LMS NOT be used?
Answer:
For parent-child communication. Use @api or custom events instead.

22. Can @wire be triggered on button click?
Answer:
No. @wire cannot be called manually.

23. How to load data on button click?
Answer:
Use imperative Apex calls.

24. Is @wire by default reactive?
Answer:
Yes.

25. Can one wire depend on another wire?
Answer:
No direct dependency. Use reactive parameters or imperative calls.

26. PubSub vs LMS (short):
Answer:
PubSub = legacy, custom, not reactive
LMS = official, reactive, secure

INTERVIEW ONE-LINER:
Lightning Message Service is the recommended, reactive, and secure way to communicate between decoupled components in Salesforce.
