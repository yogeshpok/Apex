Day First 1 21/12/2025  
https://developer.salesforce.com/docs/platform/lwc/guide
===========================================================
Lightning Web Componenet
-----------------------
Lightning Componenet Using two programing Models:
lightning Web Component and the orignal Model.

Lightning Web Component is Cutom Html component Built using the HTML and Modern JavaScript.

Lightning  Web Componenets and  aura Can Coexits and interoperate on a page to admins and user they both appear as Lightning components.

LWC is the ECMA7 standardization
AURA is the ECMA5 standardization


ECMA7
=============
1) Custom Elements -->
Avoid vendor type of element user neutral tech/element
e.g recom-- HTML,
Lightning-card,Lightning-buttton
<button></button> ---> neutral HTML
<lightning-button></lightning-button> ---> Custom vendor framework --AURA

2)Shadow DOM ---> Encapsulation (HTML + Lightning)
Mixture of the 2 technology is called ShadowDOM.

3)HTML Template ---> UI Frontend Should be .Html

4)ES Module ---> Use of modern JavaScript its not proprietary language
=====================================================================
To create the LWC componenet
-------------------------------
sf lightning generate component --type lwc --name myFirstLwc --output-dir 
sfdx force:auth:web:login -r https://login.salesforce.com/ 
sfdx force:source:deploy -p .\force-app\main\default\lwc\  -u yogesh@selfaura.com -w 20  


LWC Bundle
==============
01. Template     ----> Name.html          --->  HTML,Lightning  ---> UI Designing           --> Componenet
02. ES Module    ----> Name.js            --->  JavaScript      ---> Logic                  --> Cont,Help,rerenderer
03. Interface    ----> Name.js-meta.xml   --->  XML,lightning   ---> LWC Locatio/implement  --> Interface
04. Styles       ----> Name.css           --->  css             ---> Style(Color,SIZE etc)  --> CSS 


aura
No SVG
NO Documentation
No Design
=================================================================================================================
Aspect	              Aura Components	                        Lightning Web Components (LWC)

Framework	          Aura framework	                        Built on modern web standards

Performance	          Generally slower compared to LWC	        Significantly faster due to optimized 
                                                                rendering.

Development Model	  Event-driven and component-based	        More modular and follows a modern JavaScript
                                                                model

Syntax	              Uses Aura-specific markup and JavaScript	Utilizes HTML, JavaScript, and decorators

Learning Curve	      Steeper learning curve for beginners	    Easier for developers familiar with modern web dev

Compatibility	      Compatible with older Salesforce orgs	    May require updates for older systems and browsers

Community Support	  Well-established community and resources	Growing community with increasing support

Integration	          Can integrate with Visualforce and        Seamless integration with Salesforce platform and services
                      other Salesforce technologies	

Flexibility	          Offers flexibility in component       	Provides more flexibility with standard web dev practices
                      structure and design

Component Reusability Components can be reused within 	        Encourages component reusability and composition
                       Aura framework

Lifecycle Hooks	      Aura components have their 	            Uses standard lifecycle hooks
                      lifecycle hooks

Browser Compatibility Compatible with older browsers like       Focuses on modern browser compatibility
                       IE11 	        
=============================================================================================================================
@api
=====
To make the property public recactive use the api decorator.

import {api} from 'lwc';


Wire
====
call the apex method on the backend and get the result
get the records from backend.
wire is by default reactive when we want to automatic load of the records then we can use the reactive wire

ðŸ”¹ @wire - When the framework should manage data
Key Points:
 - Automatically invoked by the LWC lifecycle
 - Reactive to parameter changes
 - Built-in caching for better performance
âœ” Best for initial data load and read-only UI

ðŸ”¹ Imperative Calls - When the developer needs control
Key Points:
 - Manually invoked (button click / condition-based)
 - Better error handling
 - Suitable for complex or sequential logic
âœ” Best for user-driven actions and custom workflows

ðŸ” When to Use What 
 - Use @wire when data should auto-refresh
 - Use imperative calls when execution depends on user action
syntax :

import {Wire} from 'lwc';

//wire a property
@wire(getAccountINFO,{ srcText :'$sttxt'}) wiredAccounts;

//wire a function
mydata;
myerror;
@wire(getAccountINFO,{ srcText :'$sttxt'}) function({data,error})
{
    if(data)
    {
        this.mydata =data;
    }
    else{
        this.myerror = error
    }
};
================================================================
ðŸ”¥ Tricky @wire Interview Questions & Answers
Is @wire reactive or imperative?
=> @wire is reactive by default. It automatically runs when the component loads and when reactive parameters change.

Can we call @wire on button click?
=> No. @wire cannot be called manually.
For button clicks, use imperative Apex calls.

If there are multiple @wire functions, is execution order guaranteed?
=> No. Multiple @wire adapters execute independently and asynchronously.
If order is required, use reactive parameters or imperative calls.

Can one @wire call another @wire?
=> No.
But one wire can trigger another indirectly using reactive parameters ($).

Why do we use $ before a parameter in @wire?
=> $ makes the parameter reactive, so the wire re-executes automatically when the value changes.

What happens if a reactive parameter is undefined?
=> The wire does not execute until the parameter gets a valid value.

Can @wire be used with any Apex method?
=> No.
The Apex method must be annotated with:
@AuraEnabled(cacheable=true)

Can we use @wire for DML operations?
=> No.
@wire is for read-only operations only.
DML must be done imperatively.

What is the difference between wired property and wired function?
=> Wired Property	Wired Function
   Simpler	        More control
   No logic	        Custom logic
 Auto assignment	Manual assignment
// Property
@wire(getAccounts) accounts;

// Function
@wire(getAccounts)
wiredAccounts({ data, error }) {
    if (data) { this.accounts = data; }
}

Does @wire always cache data?
=> Caching works only when:
Using LDS adapters, OR
Apex method is @AuraEnabled(cacheable=true)

Can we stop a wire from running?
=> Yes, by:
Making the reactive parameter undefined or null

@wire(getAccounts, { accId: '$accountId' })
accounts;

// wire won't run if accountId is undefined

When should we avoid using @wire?
=> Avoid @wire when:
Action is user-triggered
Conditional logic is needed
Error handling is complex
DML operations are required

Is @wire synchronous or asynchronous?
=> @wire is asynchronous.

Can we refresh wired data manually?
=> Yes, using refreshApex().

Interview Killer One-Liner
=> @wire is reactive, read-only, and framework-controlled; imperative calls are manual, flexible, and developer-controlled.
==========================================================================================================================================
LWC LDS
========
Lightning Data Service does a lot of work to make code perform well.
Loads record data progressively.
Caches results on the client.
Invalidates cache entries when dependent Salesforce data and metadata changes.
Optimizes server calls by bulkifying and reducing requests.

01. Form based
========================
a) lightning record view form ---> lightning output field
b) lightning record edit form --->  lightning input field
c) lightning record  form --->  Nothing

lightning-record-edit-form    â€” Displays an editable form.
lightning-record-view-form    â€” Displays a read-only form.
lightning-record-form         â€” Supports edit, view, and read-only modes.

Feature	             lightning-record-form	lightning-record-view-form	lightning-record-edit-form
Create Records	                Yes	 	                                   Yes
Edit Records	                Yes	 	                                   Yes
View Records	                Yes	            Yes	 
https://developer.salesforce.com/docs/component-library/bundle/lightning-record-edit-form/documentation
https://developer.salesforce.com/docs/component-library/bundle/lightning-record-form/documentation
https://developer.salesforce.com/docs/component-library/bundle/lightning-record-view-form/documentation

02) programing based
====================================
a) wire service --> retrival of data

b) Imperative service (direct from LWC - No apex class)
    a) create record => createRecord(recordInput)
    b) Update record => updateRecord(recordInput)
    c) Delete record => deleteRecord(recordId)
    d) get record =>  
https://developer.salesforce.com/docs/platform/lwc/guide/reference-delete-record.html

3) Server side Imperation (Apex Call)   


===================================================================================================================================
Here is a simple breakdown of Promise vs Promise.all():

Promise
Used when you have one asynchronous operation.
Executes a single async task
Runs sequentially
Handles success or failure using .then() and .catch()
Best for one Apex call at a time

Example use case:
Fetching Account data from one Apex method.

Promise.all()
Used when you need to run multiple independent async operations in parallel.
Executes multiple async tasks together
Improves performance by running calls simultaneously
Resolves only when all promises succeed
If one fails, the entire operation goes to .catch()

Example use case:
Fetching Accounts, Contacts, and Opportunities at the same time.

Key Difference
--------------
Use Promise for a single async task
Use Promise.all() for multiple async tasks that can run in parallel

Simple takeaway:
Parallel execution = better performance, when tasks are independent.

Lifecycle Hooks
=====================
A lifecycle hook is a callback method that triggers at a specific phase of a component instances lifecycle. 
With LWC, you can use the following lifecycle hooks.

constructor()
connectedCallback() and disconnectedCallback()
renderedCallback()
errorCallback()

Lightning web components have a lifecycle managed by the framework. 
The framework creates components, inserts them into the DOM, renders them, and removes them from the DOM. 
It also monitors components for property changes.

constructor()
---------------------
The constructor() method fires when a component instance is created. 
Dont add attributes to the host element during construction. 
You can add attributes to the host element in any other lifecycle hook.
The constructor flows from parent to child, which means that it fires in the parent first. 
You can't access child elements because they don't exist yet. Properties arent passed yet, either. 
Properties are assigned to the component after construction and before the connectedCallback() hook.

Constructor Considerations 
===========================
These requirements from the HTML: Custom elements spec apply to the constructor().
The first statement must be super() with no parameters. This call establishes the correct prototype chain and value for this. Always call super() before touching this.
Donâ€™t use a return statement inside the constructor body, unless it is a simple early-return (return or return this).
Donâ€™t use the document.write() or document.open() methods.
Donâ€™t inspect the element's attributes and children, because they donâ€™t exist yet.
Donâ€™t inspect the elementâ€™s public properties, because theyâ€™re set after the component is created.

connectedCallback()
---------------------
the connectedCallback() lifecycle hook fires when a component is inserted into the DOM. 
The disconnectedCallback() lifecycle hook fires when a component is removed or hidden from the DOM. 
Both hooks flow from parent to child. To access the host element, use this. To access elements in a componentâ€™s template, use this.template.
Use
====
Establish communication with the current document or container and coordinate behavior with the environment.
Perform initialization tasks, such as fetch data, set up caches, or listen for events
Subscribe and Unsubscribe from a Message Channel.
Navigate to different page types, like records and list views using the lightning/navigation module.
Work with third-party web components.

disconnectedCallback() 
-----------------------
The disconnectedCallback() lifecycle hook fires when a component is removed or hidden from the DOM. 
Use disconnectedCallback() to clean up work done in the connectedCallback(), like purging caches or removing event listeners.

renderedCallback()
------------------
The renderedCallback() lifecycle hook is unique to Lightning Web Components.
Use it to perform logic after a component has finished the rendering phase. This hook flows from child to parent.

Render 
------
Call the render() method to update the UI. You can call it before or after connectedCallback().

errorCallback()
----------------
The errorCallback() hook is unique to Lightning Web Components. 
Implement it to create an error boundary component that captures errors in all the descendent components in its tree. 
Like a JavaScript catch{} block, errorCallback() captures errors that occur in lifecycle hooks or during an event handler declared in an HTML template. 
You can code the error boundary component to log stack information and render an alternative view to tell users what happened and what to do next.

lets say there were 2 Component One is parent and another is child What should be the lifecycle for that.
=>
 PARENT constructor
 PARENT connectedCallback
 PARENT render
 CHILD constructor
 CHILD connectedCallback
 CHILD render
 CHILD renderedCallback
 DOM accessed in renderedCallback
 PARENT renderedCallback

