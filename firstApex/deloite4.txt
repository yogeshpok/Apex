============================================================
LWC / UI Component Questions
============================================================

1) Question: Have you used a custom datatable or the standard lightning-datatable?
Answer:
- Prefer standard lightning-datatable for sorting, inline edit, accessibility, and maintenance.
- Build a custom datatable only when requirements exceed the standard component (custom cell templates, virtualization, advanced keyboard UX, etc.).

2) Question: If your datatable is dynamic and reusable, how quickly can you add a new column?
Answer:
- If metadata-driven (Custom Metadata / JSON config): typically 5‚Äì15 minutes (add metadata + deploy).
- If code-defined only: typically 30‚Äì90 minutes (update config, mapping, tests).

3) Question: How many story points would you estimate for adding a new column?
Answer (typical):
- 1 point: simple display column from an existing field.
- 2‚Äì3 points: formatting, conditional display, tooltip, server-side sort, or permissions.
- 3‚Äì5 points: new backend field, query changes, business rules, and tests.

============================================================
Security Model Questions
============================================================

4) Question: Explain the Salesforce Security Model at a high level.
Answer:
- Object-level access: Profiles / Permission Sets (CRUD).
- Field-level access: FLS (read/edit).
- Record-level access: OWD baseline + role hierarchy (if used) + sharing rules + teams + manual sharing + Apex managed sharing.
- Execution context: with sharing / without sharing impacts record access in Apex.

5) Question: Based on Account.Country__c and User.Country__c, how will you restrict access
   (Indian users ‚Üí Indian accounts, US users ‚Üí US accounts)?
Answer:
- You typically cannot do a direct "Account.Country__c = User.Country__c" equality with standard sharing rules.
- Common approach (simple + admin-friendly):
  - OWD for Account = Private.
  - Create Public Groups per country (e.g., "India Users", "US Users").
  - Maintain membership via Flow (User.Country__c drives group assignment).
  - Criteria-based sharing rules share:
    - Accounts with Country__c = 'India' to "India Users"
    - Accounts with Country__c = 'US' to "US Users"
- Alternatives:
  - Enterprise Territory Management (territories by country).
  - Apex managed sharing (AccountShare) if you need dynamic / complex rules.

6) Question: In a criteria-based sharing rule, what conditions can we use?
Answer:
- Conditions are based on fields on the record being shared (e.g., Account.Country__c = 'India', Type = 'Customer', RecordType, etc.).
- Sharing targets are roles, roles & subordinates, public groups, or territories.
- You generally cannot reference arbitrary User fields in the criteria expression itself.

============================================================
Permission Model Question
============================================================

7) Question: What is the purpose of Muting Permission Sets and how are they useful?
Answer:
- A Muting Permission Set is used with a Permission Set Group to remove (mute) specific permissions that the group would otherwise grant.
- Useful for "bundle + exceptions" without cloning many permission sets; supports least privilege.

============================================================
Business Logic / Trigger Scenario
============================================================

Scenario:
On Account, you have a field that stores number of US Contacts. Ensure it always stays updated.

8) Question: On Account, you have a field that stores number of US Contacts.
   How will you ensure it always stays updated?
Answer:
- Use a bulk-safe Contact trigger (after insert/update/delete/undelete) that recalculates counts for impacted AccountIds.
- Implementation should use one aggregate query (GROUP BY AccountId) and one bulk update to Accounts.

9) Question: How do you identify that a Contact is a US Contact?
Answer:
- Define a single rule, e.g. Contact.MailingCountry = 'United States' (or ISO code 'US'), or use a dedicated Contact.Country__c field.
- Centralize the condition in a helper method for consistency.

10) Question: If Contact.Country changes from US ‚Üí Non-US, what happens?
Answer:
- That Contact no longer qualifies; the Account count should decrease.
- Best practice is to recompute the entire count for the impacted Account(s), not do fragile +1/-1 math.

11) Question: If both Country and AccountId change simultaneously, how do you handle it?
Answer:
- Recompute counts for BOTH the old AccountId and the new AccountId:
  - The record moved (affects old and new Accounts).
  - The qualification may have changed (US vs non-US).

12) Question: Write the trigger for this entire scenario.
Answer (sample implementation; replace field API names as needed):

trigger ContactTrigger on Contact (after insert, after update, after delete, after undelete) {
    ContactUSCountService.recalcUSCounts(
        Trigger.new,
        Trigger.old,
        Trigger.isInsert,
        Trigger.isUpdate,
        Trigger.isDelete,
        Trigger.isUndelete
    );
}

public class ContactUSCountService {
    public static void recalcUSCounts(
        List<Contact> newList,
        List<Contact> oldList,
        Boolean isInsert,
        Boolean isUpdate,
        Boolean isDelete,
        Boolean isUndelete
    ) {
        Set<Id> accountIds = new Set<Id>();

        if (isInsert || isUndelete) {
            for (Contact c : newList) {
                if (c.AccountId != null) accountIds.add(c.AccountId);
            }
        }

        if (isUpdate) {
            for (Integer i = 0; i < newList.size(); i++) {
                Contact n = newList[i];
                Contact o = oldList[i];

                if (o.AccountId != null) accountIds.add(o.AccountId);
                if (n.AccountId != null) accountIds.add(n.AccountId);
            }
        }

        if (isDelete) {
            for (Contact c : oldList) {
                if (c.AccountId != null) accountIds.add(c.AccountId);
            }
        }

        if (accountIds.isEmpty()) return;

        Map<Id, Integer> countsByAccount = new Map<Id, Integer>();
        for (AggregateResult ar : [
            SELECT AccountId accId, COUNT(Id) cnt
            FROM Contact
            WHERE AccountId IN :accountIds
              AND MailingCountry = 'United States'
            GROUP BY AccountId
        ]) {
            countsByAccount.put((Id)ar.get('accId'), (Integer)ar.get('cnt'));
        }

        List<Account> toUpdate = new List<Account>();
        for (Id accId : accountIds) {
            Integer cnt = countsByAccount.containsKey(accId) ? countsByAccount.get(accId) : 0;
            toUpdate.add(new Account(
                Id = accId,
                US_Contacts_Count__c = cnt
            ));
        }

        update toUpdate;
    }
}
===========================

BARCLAY
==========
what it difference betwwn page layout and record type
what is difference between lightning page and page layout.
what is the difference between lighning page and dynamic form
explain the LWC lifrcycle hooks.
if the case having the one filed and we want to show for the one user and we dont want to show another user how we can achieve this. 
explian the owd 
wehat is custom setting and custom metadaata.


1Ô∏è‚É£ Difference between Page Layout and Record Type
Feature	Page Layout	Record Type
Purpose	Controls UI (fields, buttons, sections)	Controls business process
Fields visibility	Yes (show/hide, read-only)	No
Picklist values	No	Yes (different values per record type)
Used for	UI customization	Multiple processes on same object
Example	Show ‚ÄúDiscount‚Äù field only on layout	Separate record types for B2B & B2C Accounts
‚úÖ Simple Example

Record Type = Customer Account vs Partner Account

Page Layout = Different fields shown for each record type

üìå Record Type decides ‚ÄúWHAT type of record‚Äù
üìå Page Layout decides ‚ÄúHOW it looks‚Äù

2Ô∏è‚É£ Difference between Lightning Page and Page Layout
Feature	Lightning Page	Page Layout
UI type	Modern (Lightning Experience)	Classic + Lightning
Components	Yes (LWC, standard components)	No
Fields placement	Via components	Directly on layout
Conditional visibility	Yes	No
Multiple layouts per app/profile	Yes	Limited
‚úÖ Example

Page Layout ‚Üí Controls fields & buttons

Lightning Page ‚Üí Controls tabs, charts, related lists, LWC

üìå Think of it as:
Page Layout = Form
Lightning Page = Full Screen UI

3Ô∏è‚É£ Difference between Lightning Page and Dynamic Forms
Feature	Lightning Page	Dynamic Forms
Purpose	Page structure	Field-level control
Conditional visibility	Component-level	Field & section-level
Uses Page Layout?	Yes	No (replaces layout)
Field placement	Grouped	Individual control
‚úÖ Example

Lightning Page ‚Üí Where components are placed

Dynamic Forms ‚Üí Show/Hide fields based on user, role, record data

üìå Dynamic Forms = Advanced Page Layout in Lightning

4Ô∏è‚É£ LWC Lifecycle Hooks (Very Important for Interviews)
üîπ Lifecycle Flow

1Ô∏è‚É£ constructor()

Runs first

Initialize variables

No DOM access

2Ô∏è‚É£ connectedCallback()

Component inserted into DOM

Call Apex / load data

3Ô∏è‚É£ render()

Returns HTML template

4Ô∏è‚É£ renderedCallback()

DOM is ready

Manipulate DOM (careful of loops)

5Ô∏è‚É£ disconnectedCallback()

Component removed

Cleanup (timers, listeners)

6Ô∏è‚É£ errorCallback(error, stack)

Handles child component errors

‚úÖ Example
constructor() {
  super();
}

connectedCallback() {
  console.log('Component Loaded');
}

renderedCallback() {
  console.log('DOM Ready');
}


üìå connectedCallback = Apex calls
üìå renderedCallback = DOM logic

5Ô∏è‚É£ Show a Field to One User but Hide from Another
‚úÖ Best Approaches (Interview-Approved)
‚úî Option 1: Field-Level Security (FLS)

Hide field from specific profiles

‚úî Option 2: Dynamic Forms (Recommended)

Visibility rule based on:

User Profile

Role

Permission

Record values

‚úî Option 3: Permission Set

Grant field access to selected users

‚úî Option 4: LWC / Lightning Page Visibility Filter

Control visibility at component level

üìå Best Answer:
üëâ Use Permission Sets + Dynamic Forms

6Ô∏è‚É£ What is OWD (Organization-Wide Defaults)
üîπ Definition

OWD defines baseline record access for users who are not above in role hierarchy.

üîπ OWD Options

Private

Public Read Only

Public Read/Write

‚úÖ Example

Account OWD = Private

User A creates Account

User B cannot see it unless:

Role hierarchy

Sharing rule

Manual sharing

üìå OWD = Most restrictive access

7Ô∏è‚É£ Difference between Custom Settings and Custom Metadata
Feature	Custom Setting	Custom Metadata
Data type	App data	Configuration data
Deployment	‚ùå Manual	‚úÖ With metadata
SOQL allowed	No (direct access)	Yes
Access	Cached	Cached
Security	Can be profile/user specific	Admin only
Use case	User-specific config	App-wide config
‚úÖ Example

Custom Setting ‚Üí User-wise discount limit

Custom Metadata ‚Üí Tax % or API URL

üìå Best Practice:
üëâ Use Custom Metadata instead of Custom Settings

































